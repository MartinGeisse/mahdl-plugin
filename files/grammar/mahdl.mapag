%terminals {

    // parentheses, braces and brackets
    OPENING_PARENTHESIS, CLOSING_PARENTHESIS, OPENING_SQUARE_BRACKET, CLOSING_SQUARE_BRACKET, OPENING_CURLY_BRACE, CLOSING_CURLY_BRACE,

    // other puctuation
    DOT, COLON, SEMICOLON, COMMA, EQUALS,

    // bit and vector operators
    OP_NOT, OP_AND, OP_OR, OP_XOR, OP_SHIFT_LEFT, OP_SHIFT_RIGHT,

    // arithmetic operators
    OP_PLUS, OP_MINUS, OP_TIMES, OP_DIVIDED_BY, OP_REMAINDER,

    // comparison operators
    OP_EQUAL, OP_NOT_EQUAL, OP_GREATER_THAN, OP_GREATER_THAN_OR_EQUAL, OP_LESS_THAN, OP_LESS_THAN_OR_EQUAL,

    // other operators
    OP_MUX, OP_CONCAT,

    // keywords
    KW_MODULE, KW_INTERFACE, KW_CONST, KW_INPUT, KW_OUTPUT, KW_INOUT,
    KW_BIT, KW_VECTOR, KW_MEMORY, KW_INTEGER, KW_TEXT,
    KW_DO, KW_IF, KW_ELSE, KW_SWITCH, KW_CASE, KW_DEFAULT, KW_BREAK,

    // literals
    INTEGER_LITERAL, VECTOR_LITERAL, TEXT_LITERAL,

    // identifiers
    IDENTIFIER,

    // comments (never passed to the parser, but unlike whitespace we need them in the symbols holder class because
    // IntelliJ doesn't define a generic IElementType for comments)
    BLOCK_COMMENT, LINE_COMMENT

}

// Note: unary prefix operators actually need only one "representative" operator in this table. Everything else is rule
// precedences. We use OP_NOT for that.
%precedence {
    %right OP_MUX;
    %left OP_OR;
    %left OP_XOR;
    %left OP_AND;
    %left OP_EQUAL, OP_NOT_EQUAL;
    %left OP_GREATER_THAN, OP_GREATER_THAN_OR_EQUAL, OP_LESS_THAN, OP_LESS_THAN_OR_EQUAL;
    %left OP_SHIFT_LEFT, OP_SHIFT_RIGHT;
    %left OP_CONCAT;
    %left OP_PLUS, OP_MINUS;
    %left OP_TIMES, OP_DIVIDED_BY, OP_REMAINDER;
    %nonassoc OP_NOT;
    %nonassoc OPENING_SQUARE_BRACKET;
}

%start module;



//
// toplevel / modules
//

module ::= KW_MODULE IDENTIFIER:moduleName SEMICOLON
        KW_INTERFACE OPENING_CURLY_BRACE interfaceItem*:interfaceItems CLOSING_CURLY_BRACE
        implementationItem*:implementationItems;


//
// interface
//

interfaceItem ::= portDirection:direction dataType:dataType (IDENTIFIER, COMMA)+:identifiers SEMICOLON;

portDirection ::= {
    const ::= KW_CONST;
    input ::= KW_INPUT;
    output ::= KW_OUTPUT;
    inout ::= KW_INOUT;
}


//
// implementation
//

implementationItem ::= {
    signalDeclaration ::= dataType:dataType (declaredSignal, COMMA)+ SEMICOLON;
    moduleInstance ::= qualifiedIdentifier:moduleName IDENTIFIER:instanceName OPENING_PARENTHESIS portConnection*:portConnections CLOSING_PARENTHESIS SEMICOLON;
    doBlock ::= KW_DO OPENING_PARENTHESIS expression:expression CLOSING_PARENTHESIS statement:statement;
}

declaredSignal ::= {
    withoutInitializer ::= IDENTIFIER:identifier;
    withInitializer ::= IDENTIFIER:identifier EQUALS expression;
// TODO info: a signal with a constant initializer can be either a constant wire or a register with initial value --
// the difference is made by whether it gets assigned in a clocked block. A signal with an initializer cannot be assigned
// to in a combinatorial block. A signal without initializer must be assigned to, and is either a wire or register
// depending on whether it is assigned to in a combinatorial or clocked block.
}

portConnection ::= DOT IDENTIFIER:portName EQUALS expression:expression SEMICOLON;

statement ::= {
    assignment ::= expression:leftSide EQUALS expression:rightSide SEMICOLON;
    ifThen ::= KW_IF OPENING_PARENTHESIS expression:condition CLOSING_PARENTHESIS statement:thenBranch %resolve {
        %shift KW_ELSE;
    };
    ifThenElse ::= KW_IF OPENING_PARENTHESIS expression:condition CLOSING_PARENTHESIS statement:thenBranch KW_ELSE statement:elseBranch;
    switch ::= KW_SWITCH OPENING_PARENTHESIS expression:expression CLOSING_PARENTHESIS OPENING_CURLY_BRACE caseItem+:items CLOSING_CURLY_BRACE;
    block ::= OPENING_CURLY_BRACE statement*:body CLOSING_CURLY_BRACE;
    break ::= KW_BREAK SEMICOLON;
}

caseItem ::= {
    value ::= KW_CASE expression:value COLON statement*:statements;
    default ::= KW_DEFAULT COLON statement*:statements;
}

expression ::= {

    literal ::= literal:literal;
    signal ::= IDENTIFIER:signalName;
    instancePort ::= IDENTIFIER:instanceName DOT IDENTIFIER:portName;
    indexSelection ::= expression:container OPENING_SQUARE_BRACKET expression:index CLOSING_CURLY_BRACE;
    rangeSelection ::= expression:container OPENING_SQUARE_BRACKET expression:from COLON expression:to CLOSING_CURLY_BRACE;
    parenthesized ::= OPENING_PARENTHESIS expression:expression CLOSING_PARENTHESIS;
    functionCall ::= IDENTIFIER:functionName OPENING_PARENTHESIS (expression, COMMA)+:arguments CLOSING_PARENTHESIS;

    unaryNot ::= OP_NOT expression:operand %precedence OP_NOT;
    unaryPlus ::= OP_PLUS expression:operand %precedence OP_NOT;
    unaryMinus ::= OP_MINUS expression:operand %precedence OP_NOT;

    binaryPlus ::= expression:leftOperand OP_PLUS expression:rightOperand %precedence OP_PLUS;
    binaryMinus ::= expression:leftOperand OP_MINUS expression:rightOperand %precedence OP_MINUS;
    binaryTimes ::= expression:leftOperand OP_TIMES expression:rightOperand %precedence OP_TIMES;
    binaryDividedBy ::= expression:leftOperand OP_DIVIDED_BY expression:rightOperand %precedence OP_DIVIDED_BY;
    binaryRemainder ::= expression:leftOperand OP_REMAINDER expression:rightOperand %precedence OP_REMAINDER;

    binaryEqual ::= expression:leftOperand OP_EQUAL expression:rightOperand %precedence OP_EQUAL;
    binaryNotEqual ::= expression:leftOperand OP_NOT_EQUAL expression:rightOperand %precedence OP_NOT_EQUAL;
    binaryGreaterThan ::= expression:leftOperand OP_GREATER_THAN expression:rightOperand %precedence OP_GREATER_THAN;
    binaryGreaterThanOrEqual ::= expression:leftOperand OP_GREATER_THAN_OR_EQUAL expression:rightOperand %precedence OP_GREATER_THAN_OR_EQUAL;
    binaryLessThan ::= expression:leftOperand OP_LESS_THAN expression:rightOperand %precedence OP_LESS_THAN;
    binaryLessThanOrEqual ::= expression:leftOperand OP_LESS_THAN_OR_EQUAL expression:rightOperand %precedence OP_LESS_THAN_OR_EQUAL;

    binaryBitwiseAnd ::= expression:leftOperand OP_AND expression:rightOperand %precedence OP_AND;
    binaryBitwiseOr ::= expression:leftOperand OP_OR expression:rightOperand %precedence OP_OR;
    binaryBitwiseXor ::= expression:leftOperand OP_XOR expression:rightOperand %precedence OP_XOR;
    binaryShiftLeft ::= expression:leftOperand OP_SHIFT_LEFT expression:rightOperand %precedence OP_SHIFT_LEFT;
    binaryShiftRight ::= expression:leftOperand OP_SHIFT_RIGHT expression:rightOperand %precedence OP_SHIFT_RIGHT;

    binaryConcat ::= expression:leftOperand OP_CONCAT expression:rightOperand %precedence OP_CONCAT;

    mux ::= expression:condition OP_MUX expression:thenBranch COLON expression:elseBranch %precedence OP_MUX;

}

literal ::= {
    integer ::= INTEGER_LITERAL:value;
    vector ::= VECTOR_LITERAL:value;
    text ::= TEXT_LITERAL:value;
}

//
// common
//

dataType ::= {
    bit ::= KW_BIT;
    vector ::= KW_VECTOR OPENING_SQUARE_BRACKET expression:size CLOSING_SQUARE_BRACKET;
    memory ::= KW_MEMORY OPENING_SQUARE_BRACKET expression:firstSize CLOSING_SQUARE_BRACKET OPENING_SQUARE_BRACKET expression:secondSize CLOSING_SQUARE_BRACKET;
    integer ::= KW_INTEGER;
    text ::= KW_TEXT;
}

qualifiedIdentifier ::= (IDENTIFIER, DOT)+:segments;
