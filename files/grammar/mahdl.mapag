%terminals {

	// parentheses, braces and brackets
	OPENING_PARENTHESIS, CLOSING_PARENTHESIS, OPENING_SQUARE_BRACKET, CLOSING_SQUARE_BRACKET, OPENING_CURLY_BRACE, CLOSING_CURLY_BRACE,

	// other puctuation
	DOT, COLON, SEMICOLON, COMMA, EQUALS,

	// bit and vector operators
	OP_NOT, OP_AND, OP_OR, OP_XOR, OP_SHIFT_LEFT, OP_SHIFT_RIGHT,

	// arithmetic operators
	OP_PLUS, OP_MINUS, OP_TIMES, OP_DIVIDED_BY, OP_REMAINDER,

	// comparison operators
	OP_EQUAL, OP_NOT_EQUAL, OP_GREATER_THAN, OP_GREATER_THAN_OR_EQUAL, OP_LESS_THAN, OP_LESS_THAN_OR_EQUAL,

	// other operators
	OP_MUX, OP_CONCAT,

	// keywords
	KW_MODULE, KW_INTERFACE, KW_INPUT, KW_OUTPUT, KW_INOUT,
	KW_CONSTANT, KW_SIGNAL, KW_REGISTER,
	KW_BIT, KW_VECTOR, KW_MEMORY, KW_INTEGER, KW_TEXT,
	KW_DO, KW_IF, KW_ELSE, KW_SWITCH, KW_CASE, KW_DEFAULT, KW_BREAK,

	// literals
	INTEGER_LITERAL, VECTOR_LITERAL, TEXT_LITERAL,

	// identifiers
	IDENTIFIER,

	// comments (never passed to the parser, but unlike whitespace we need them in the symbols holder class because
	// IntelliJ doesn't define a generic IElementType for comments)
	BLOCK_COMMENT, LINE_COMMENT

}

// Note: unary prefix operators actually need only one "representative" operator in this table. Everything else is rule
// precedences. We use OP_NOT for that.
%precedence {
	%right OP_MUX;
	%left OP_OR;
	%left OP_XOR;
	%left OP_AND;
	%left OP_EQUAL, OP_NOT_EQUAL;
	%left OP_GREATER_THAN, OP_GREATER_THAN_OR_EQUAL, OP_LESS_THAN, OP_LESS_THAN_OR_EQUAL;
	%left OP_SHIFT_LEFT, OP_SHIFT_RIGHT;
	%left OP_CONCAT;
	%left OP_PLUS, OP_MINUS;
	%left OP_TIMES, OP_DIVIDED_BY, OP_REMAINDER;
	%nonassoc OP_NOT;
	%nonassoc OPENING_SQUARE_BRACKET;
}

%start module;



//
// toplevel / modules
//

module ::= KW_MODULE IDENTIFIER:moduleName SEMICOLON
		KW_INTERFACE OPENING_CURLY_BRACE portDefinitionGroup*:portDefinitionGroups CLOSING_CURLY_BRACE
		implementationItem*:implementationItems;

//
// interface
//

portDefinitionGroup ::= portDirection:direction dataType:dataType (portDefinition, COMMA)+:definitions SEMICOLON;

portDefinition ::= IDENTIFIER:identifier;

portDirection ::= {
	input ::= KW_INPUT;
	output ::= KW_OUTPUT;
	inout ::= KW_INOUT;
}


//
// implementation (general)
//

implementationItem ::= {
	signalLikeDefinitionGroup ::= signalLikeKind:kind dataType:dataType (signalLikeDefinition, COMMA)+:definitions SEMICOLON;
	moduleInstance ::= qualifiedModuleName:moduleName instanceName:instanceName OPENING_PARENTHESIS portConnection*:portConnections CLOSING_PARENTHESIS SEMICOLON;
	doBlock ::= KW_DO OPENING_PARENTHESIS doBlockTrigger:trigger CLOSING_PARENTHESIS statement:statement;
	error ::= %error; // synchronizes on the start of the next item
}



//
// signal-like objects
//

signalLikeKind ::= {
	constant ::= KW_CONSTANT;
	signal ::= KW_SIGNAL;
	register ::= KW_REGISTER;
}

signalLikeDefinition ::= {
	withoutInitializer ::= IDENTIFIER:identifier;
	withInitializer ::= IDENTIFIER:identifier EQUALS expression:initializer;
}


//
// module instances
//

qualifiedModuleName ::= (IDENTIFIER, DOT)+:segments;

instanceName ::= IDENTIFIER:identifier;

portConnection ::= instancePortName:portName COLON expression:expression SEMICOLON;

instancePortName ::= IDENTIFIER:identifier;


//
// do-blocks and statements
//

doBlockTrigger ::= {
	combinatorial ::= OP_TIMES;
	clocked ::= expression:clockExpression;
}

statement ::= {
	assignment ::= expression:leftSide EQUALS expression:rightSide SEMICOLON;
	ifThen ::= KW_IF OPENING_PARENTHESIS expression:condition CLOSING_PARENTHESIS statement:thenBranch %resolve {
		%shift KW_ELSE;
	};
	ifThenElse ::= KW_IF OPENING_PARENTHESIS expression:condition CLOSING_PARENTHESIS statement:thenBranch KW_ELSE statement:elseBranch;
	switch ::= KW_SWITCH OPENING_PARENTHESIS expression:expression CLOSING_PARENTHESIS OPENING_CURLY_BRACE caseItem+:items CLOSING_CURLY_BRACE;
	block ::= OPENING_CURLY_BRACE statement*:body CLOSING_CURLY_BRACE;
	break ::= KW_BREAK SEMICOLON;
}

caseItem ::= {
	value ::= KW_CASE expression:value COLON statement*:statements;
	default ::= KW_DEFAULT COLON statement*:statements;
}


//
// expressions
//

expression ::= {

	literal ::= literal:literal;
	identifier ::= IDENTIFIER:identifier;
	instancePort ::= instanceReferenceName:instanceName DOT instancePortName:portName;
	indexSelection ::= expression:container OPENING_SQUARE_BRACKET expression:index CLOSING_SQUARE_BRACKET;
	rangeSelection ::= expression:container OPENING_SQUARE_BRACKET expression:from COLON expression:to CLOSING_SQUARE_BRACKET;
	parenthesized ::= OPENING_PARENTHESIS expression:expression CLOSING_PARENTHESIS;
	functionCall ::= IDENTIFIER:functionName OPENING_PARENTHESIS (expression, COMMA)+:arguments CLOSING_PARENTHESIS;

	unaryNot ::= OP_NOT expression:operand %precedence OP_NOT;
	unaryPlus ::= OP_PLUS expression:operand %precedence OP_NOT;
	unaryMinus ::= OP_MINUS expression:operand %precedence OP_NOT;

	binaryPlus ::= expression:leftOperand OP_PLUS expression:rightOperand %precedence OP_PLUS;
	binaryMinus ::= expression:leftOperand OP_MINUS expression:rightOperand %precedence OP_MINUS;
	binaryTimes ::= expression:leftOperand OP_TIMES expression:rightOperand %precedence OP_TIMES;
	binaryDividedBy ::= expression:leftOperand OP_DIVIDED_BY expression:rightOperand %precedence OP_DIVIDED_BY;
	binaryRemainder ::= expression:leftOperand OP_REMAINDER expression:rightOperand %precedence OP_REMAINDER;

	binaryEqual ::= expression:leftOperand OP_EQUAL expression:rightOperand %precedence OP_EQUAL;
	binaryNotEqual ::= expression:leftOperand OP_NOT_EQUAL expression:rightOperand %precedence OP_NOT_EQUAL;
	binaryGreaterThan ::= expression:leftOperand OP_GREATER_THAN expression:rightOperand %precedence OP_GREATER_THAN;
	binaryGreaterThanOrEqual ::= expression:leftOperand OP_GREATER_THAN_OR_EQUAL expression:rightOperand %precedence OP_GREATER_THAN_OR_EQUAL;
	binaryLessThan ::= expression:leftOperand OP_LESS_THAN expression:rightOperand %precedence OP_LESS_THAN;
	binaryLessThanOrEqual ::= expression:leftOperand OP_LESS_THAN_OR_EQUAL expression:rightOperand %precedence OP_LESS_THAN_OR_EQUAL;

	binaryAnd ::= expression:leftOperand OP_AND expression:rightOperand %precedence OP_AND;
	binaryOr ::= expression:leftOperand OP_OR expression:rightOperand %precedence OP_OR;
	binaryXor ::= expression:leftOperand OP_XOR expression:rightOperand %precedence OP_XOR;
	binaryShiftLeft ::= expression:leftOperand OP_SHIFT_LEFT expression:rightOperand %precedence OP_SHIFT_LEFT;
	binaryShiftRight ::= expression:leftOperand OP_SHIFT_RIGHT expression:rightOperand %precedence OP_SHIFT_RIGHT;

	binaryConcat ::= expression:leftOperand OP_CONCAT expression:rightOperand %precedence OP_CONCAT;

	mux ::= expression:condition OP_MUX expression:thenBranch COLON expression:elseBranch %precedence OP_MUX;

}

instanceReferenceName ::= IDENTIFIER:identifier;

literal ::= {
	integer ::= INTEGER_LITERAL:value;
	vector ::= VECTOR_LITERAL:value;
	text ::= TEXT_LITERAL:value;
}

//
// common
//

dataType ::= {
	bit ::= KW_BIT;
	vector ::= KW_VECTOR OPENING_SQUARE_BRACKET expression:size CLOSING_SQUARE_BRACKET;
	memory ::= KW_MEMORY OPENING_SQUARE_BRACKET expression:firstSize CLOSING_SQUARE_BRACKET OPENING_SQUARE_BRACKET expression:secondSize CLOSING_SQUARE_BRACKET;
	integer ::= KW_INTEGER;
	text ::= KW_TEXT;
}
